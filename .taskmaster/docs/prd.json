{
  "project_name": "智能购物助手系统 (Intelligent Shopping Assistant System)",
  "methodology": {
    "name": "The Ultimate Full-Stack Workflow",
    "philosophy": "Contract-First, Test-Driven, Infrastructure-First, and Continuous Integration.",
    "description": "本计划遵循一个严格的工作流，首先建立坚实的、自动化的基础架构，然后以API合约为驱动，通过测试保障，对每个功能进行迭代开发。这确保了开发过程的高效、并行和高质量交付。"
  },
  "phase_0_foundation": {
    "title": "阶段零：基础架构与自动化工厂搭建 (Foundation & Infrastructure)",
    "description": "在编写任何功能代码之前，必须完成的、一次性的、非协商性的基础工作。此阶段的目标是建立一个全自动的开发、测试和部署高速公路。",
    "tasks": [
      {
        "id": "F-1",
        "title": "初始化项目 (Monorepo Setup)",
        "action": "使用 pnpm workspaces 或 yarn workspaces 设置一个包含 `backend` 和 `frontend` 包的 Monorepo。",
        "outcome": "一个统一的代码仓库，便于管理前后端代码和共享配置。"
      },
      {
        "id": "F-2",
        "title": "设置API合约 (Initialize OpenAPI Contract)",
        "action": "在项目根目录创建 `openapi.yml` 文件。此文件将作为所有API定义的唯一事实来源 (Single Source of Truth)。",
        "outcome": "一个中心化的API合约，后端和前端将严格遵守此约定进行开发。"
      },
      {
        "id": "F-3",
        "title": "搭建核心后端服务 (Core Backend Service)",
        "original_task_id": 16,
        "action": "使用 FastAPI 搭建Web服务器，配置基础路由和标准化的JSON响应中间件。确保内置的OpenAPI文档 (`/docs`) 能够根据 `openapi.yml` 自动生成。",
        "outcome": "一个可以运行并提供基础API文档的后端服务器。"
      },
      {
        "id": "F-4",
        "title": "安装核心依赖 (Install Core Dependencies)",
        "action": {
          "frontend": "安装并配置UI组件库 (如 Ant Design), 状态管理库 (如 Zustand), 和测试框架 (Vitest 用于单元测试, Playwright/Cypress 用于E2E测试)。",
          "backend": "安装并配置测试框架 (如 Pytest) 及相关的HTTP客户端库 (如 httpx)。"
        },
        "outcome": "前后端开发所需的核心工具集已就绪。"
      },
      {
        "id": "F-5",
        "title": "容器化 (Containerization)",
        "action": "为后端和前端服务分别创建 `Dockerfile`，并创建一个 `docker-compose.yml` 文件来编排本地开发、测试和生产环境。",
        "outcome": "确保绝对一致的运行环境，消除\"在我电脑上可以运行\"的问题。"
      },
      {
        "id": "F-6",
        "title": "建立CI/CD流水线 (CI/CD Pipeline 'Hello World' Deployment)",
        "original_task_id": 33,
        "action": "使用 GitHub Actions 或类似工具建立CI/CD流水线。该流水线应能自动运行所有测试（目前为空）、构建Docker镜像、推送到容器仓库，并成功部署一个\"Hello World\"应用到生产或预发环境。",
        "outcome": "一个全自动的验证和部署流程。从此开始，每一次代码提交都将得到全面验证。"
      },
      {
        "id": "F-7",
        "title": "配置管理 (Secrets & Configuration Management)",
        "original_task_id": 34,
        "action": "集成 `python-dotenv` 或更强大的配置管理工具（如 HashiCorp Vault），统一管理API密钥、数据库凭据等敏感信息。确保CI/CD和本地开发环境都能安全、一致地加载配置。",
        "outcome": "安全、可维护的配置管理机制，将配置与代码分离。"
      }
    ]
  },
  "development_loop_features": {
    "title": "开发循环：合约驱动的功能切片 (Contract-Driven Feature Slicing)",
    "description": "对于每一个独立的功能，严格按照以下7个步骤顺序执行。所有任务的状态和依赖关系均已考虑并整合到此流程中。",
    "features": [
      {
        "feature_name": "智能输入解析与意图分析 (Intelligent Input Parsing & Intent Analysis)",
        "user_story": "作为用户，我希望能输入一段包含商品链接和文本的混合内容，系统能智能地识别出商品链接并获取详情；如果只有文本，系统能分析我的购物意图。",
        "original_task_ids": [17, 18, 19, 32],
        "status": "done",
        "steps": [
          {
            "step": 0,
            "title": "定义合约 (Define the Contract)",
            "action": "在 `openapi.yml` 中定义 `/api/v1/intent/parse` 端点。规定其 `POST` 方法，请求体包含 `userInput` 字段，并详细定义成功响应（包含解析出的URL信息、商品详情）和错误响应（如LLM分析结果、速率限制错误）。"
          },
          {
            "step": 1,
            "title": "数据库与模型 (Database & Models)",
            "action": "此功能初期不直接涉及数据库写入，主要依赖外部API。数据库模型将在 'QC Image Gallery' 功能中定义。"
          },
          {
            "step": 2,
            "title": "后端业务逻辑与单元测试 (Backend Business Logic & Unit Tests)",
            "action": "实现 `app.services.preprocessor` 模块，包含：1. URL和文本分离逻辑。2. URL解析逻辑（淘宝、1688、微店）。3. 决策逻辑（有URL则跳过LLM）。为每个纯函数编写单元测试，覆盖各种输入组合。",
            "test_strategy": "针对 `preprocessor` 模块编写单元测试，验证其对直接链接、带参数链接、代理链接的解析能力，并断言决策逻辑的正确性。"
          },
          {
            "step": 3,
            "title": "后端API与集成测试 (Backend API & Integration Tests)",
            "action": "实现 `/api/v1/intent/parse` API端点。该端点调用预处理器，并根据结果：a) 若解析出商品，则调用 `daji_service` 或 `weidian_service` 获取商品详情。b) 若只有文本，则调用 `llm_service` (包含速率限制) 进行意图分析。编写集成测试，mock掉外部API调用，验证端点在不同输入下是否遵循合约返回了正确的结构和状态码（200, 429）。"
          },
          {
            "step": 4,
            "title": "前端状态与数据逻辑 (Frontend State & Data Logic)",
            "action": "在前端创建一个 `useIntentStore` (Zustand) 或类似的状态钩子，包含一个 `parseIntent(userInput)` 的异步action。此action负责调用后端API，并管理 `isLoading`, `data`, `error` 状态。"
          },
          {
            "step": 5,
            "title": "前端UI与组件库 (Frontend UI & Component Library)",
            "action": "使用UI组件库创建一个包含 `<Input.TextArea>` 和 `<Button>` 的表单。用户点击按钮时，调用 `parseIntent` action。根据store中的状态，展示加载动画、解析结果（商品卡片）或意图分析消息。"
          },
          {
            "step": 6,
            "title": "端到端测试 (End-to-End Tests)",
            "action": "编写一个E2E测试脚本 (Playwright/Cypress)：1. 访问应用页面。2. 在输入框中输入一个淘宝链接。3. 点击提交按钮。4. 断言页面上是否正确显示了该商品的标题和价格。"
          }
        ]
      },
      {
        "feature_name": "QC图片库 (QC Image Gallery)",
        "user_story": "作为用户，当我查询一个商品时，如果系统内部有该商品的质检(QC)图，我希望能看到这些图片。",
        "original_task_ids": [21, 22],
        "status": "pending",
        "steps": [
          {
            "step": 0,
            "title": "定义合约 (Define the Contract)",
            "action": "在 `openapi.yml` 中定义 `/api/v1/products/qc` 端点。使用 `GET` 方法，参数为 `platform` 和 `product_id`。定义成功响应（包含图库和图片信息的数组）和 `404 Not Found` 响应。"
          },
          {
            "step": 1,
            "title": "数据库与模型 (Database & Models)",
            "action": "根据任务21的设计，使用 SQLAlchemy ORM 创建 `platforms`, `agents`, `products`, `qc_galleries`, `qc_photos` 五个模型，并使用 Alembic 创建数据库迁移脚本。",
            "test_strategy": "在迁移脚本完成后，编写一个测试验证模型是否能成功创建和关联。"
          },
          {
            "step": 2,
            "title": "后端业务逻辑与单元测试 (Backend Business Logic & Unit Tests)",
            "action": "实现 `app.services.qc_service`，包含 `get_qc_gallery_by_product` 函数。该函数执行数据库查询，通过JOIN一次性获取商品所有QC信息。为数据摄取管道（任务22）编写ETL脚本的业务逻辑，并进行单元测试。"
          },
          {
            "step": 3,
            "title": "后端API与集成测试 (Backend API & Integration Tests)",
            "action": "实现 `/api/v1/products/qc` 端点，调用 `qc_service`。编写集成测试，先在测试数据库中填充样本数据，然后调用API，断言返回的数据结构和内容与预期一致。",
            "test_strategy": "集成测试需要验证 `ON DELETE CASCADE` 约束是否按预期工作。"
          },
          {
            "step": 4,
            "title": "前端状态与数据逻辑 (Frontend State & Data Logic)",
            "action": "扩展 `useProductStore`，添加 `fetchQCGallery(platform, productId)` action，用于在需要时加载QC图片。"
          },
          {
            "step": 5,
            "title": "前端UI与组件库 (Frontend UI & Component Library)",
            "action": "在商品详情展示区，如果检测到QC数据存在，则渲染一个图片画廊组件（如 `<Carousel>` 或 `<Image.PreviewGroup>`）来展示QC图片。"
          },
          {
            "step": 6,
            "title": "端到端测试 (End-to-End Tests)",
            "action": "编写E2E测试：1. 访问一个已知有QC图的商品页面。2. 断言QC图库组件已显示。3. 点击图片可以进行预览或轮播。"
          }
        ]
      },
      {
        "feature_name": "图片搜索与结果聚合处理 (Image Search & Result Aggregation)",
        "user_story": "作为用户，我希望能上传一张商品图片，系统能并发搜索多个电商平台（腾讯云、1688、淘宝），然后将结果合并、去重、排序后展示给我。",
        "original_task_ids": [20, 24, 25, 26, 36],
        "status": "pending",
        "steps": [
          {
            "step": 0,
            "title": "定义合约 (Define the Contract)",
            "action": "在 `openapi.yml` 中定义 `/api/v1/search/image` 端点。`POST` 方法，请求体为 `multipart/form-data`，包含一个图片文件。定义成功响应（包含 `finalScore` 和其他标准化字段的商品列表）和各种错误响应。"
          },
          {
            "step": 1,
            "title": "数据库与模型 (Database & Models)",
            "action": "此功能将读取 'QC图片库' 的数据来计算 `reliabilityScore`，但本身不定义新的核心模型。"
          },
          {
            "step": 2,
            "title": "后端业务逻辑与单元测试 (Backend Business Logic & Unit Tests)",
            "action": "1. **聚合器(Aggregator)**: 实现 `services/search_aggregator.py`，使用 `asyncio.gather` 并发调用三个平台的图片搜索API封装器。2. **合并器(Merger)**: 实现结果合并与去重逻辑，优先保留腾讯云结果，并映射各平台特有标签。3. **排名器(Ranker)**: 实现多因子评分算法，计算 `reliabilityScore`, `tencent_quality_score`, `similarityScore` 等，并根据权重计算 `finalScore`。为每个逻辑模块编写详尽的单元测试。"
          },
          {
            "step": 3,
            "title": "后端API与集成测试 (Backend API & Integration Tests)",
            "action": "实现 `/api/v1/search/image` 端点，串联调用聚合器、合并器、排名器，最后通过格式化模块返回最终响应。编写集成测试，mock掉三个搜索API，提供复杂的、重叠的结果集，断言最终返回的列表是唯一的、正确排序的，并且 `finalScore` 计算符合预期。"
          },
          {
            "step": 4,
            "title": "前端状态与数据逻辑 (Frontend State & Data Logic)",
            "action": "创建 `useImageSearchStore`，包含 `searchByImage(file)` action，处理文件上传和API调用，并管理`isUploading`, `results`, `error` 状态。"
          },
          {
            "step": 5,
            "title": "前端UI与组件库 (Frontend UI & Component Library)",
            "action": "使用 `<Upload>` 组件允许用户上传图片。在结果区，使用 `<List>` 或 `<Card>` 循环展示返回的商品列表。添加排序控件（任务35），允许用户在前端按价格、`finalScore` 等进行二次排序。"
          },
          {
            "step": 6,
            "title": "端到端测试 (End-to-End Tests)",
            "action": "编写E2E测试：1. 访问图片搜索页面。2. 上传一张测试图片。3. 断言结果列表中展示了预期的商品。4. 点击价格排序按钮。5. 断言列表顺序发生改变且符合预期。"
          }
        ]
      }
    ]
  },
  "system_wide_epics": {
    "title": "系统级史诗任务 (System-wide Epics)",
    "description": "这些是跨功能的、系统级的改进项，应在整个开发生命周期中持续关注和实施。",
    "epics": [
      {
        "id": "E-1",
        "title": "健壮的错误处理与重试 (Robust Error Handling & Retries)",
        "original_task_id": 27,
        "action": "设计并实现统一的异常模型和集中的错误处理中间件。为所有外部API调用（如Da-ji, RapidAPI, LLM）封装带指数退避的重试装饰器。"
      },
      {
        "id": "E-2",
        "title": "缓存与性能优化 (Caching & Performance Optimization)",
        "original_task_id": 28,
        "action": "分析性能瓶颈，对外部API响应和高频查询结果（如QC图库）引入Redis或内存缓存层。进行负载测试以验证优化效果。"
      },
      {
        "id": "E-3",
        "title": "监控与警报 (Monitoring & Alerting)",
        "original_task_id": 30,
        "action": "集成Prometheus和Grafana。在FastAPI应用中暴露关键指标（如请求延迟、错误率、外部API健康状况）。设置警报规则，当关键指标超出阈值时通过PagerDuty或Slack通知团队。"
      },
      {
        "id": "E-4",
        "title": "用户反馈与个性化 (User Feedback & Personalization)",
        "original_task_id": 29,
        "action": "规划并实现用户反馈API和数据库模式，允许用户对搜索结果进行评分。将反馈数据作为新的因子，迭代优化排名算法。"
      },
      {
        "id": "E-5",
        "title": "可扩展性与弹性 (Scalability & Resilience)",
        "original_task_id": 31,
        "action": "设计支持水平扩展的架构，如使用Kubernetes的HPA（Horizontal Pod Autoscaler）。部署负载均衡器，并制定数据库备份和灾难恢复策略。"
      }
    ]
  },
  "metadata": {
    "file_generated_at": "2024-05-21T10:00:00Z",
    "generated_by": "Professional Project Manager AI",
    "original_data_timestamps": {
      "created": "2025-06-17T06:40:47.197Z",
      "updated": "2025-06-19T01:53:06.998Z"
    }
  }
} 